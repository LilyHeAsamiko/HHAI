# -*- coding: utf-8 -*-
"""QSVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13OSLY7Iu44rt44E-h5SXgh-C34AsiL4m
"""

!pip install qiskit

!pip install matplotlib

!pip install torch

import numpy as np
import matplotlib.pyplot as plt

import torch
from torch.autograd import Function
from torchvision import datasets, transforms
import torch.optim as optim
import torch.nn as nn
import torch.nn.functional as F

import qiskit
from qiskit import transpile, assemble
from qiskit.visualization import *

X_Train = datasets.MNIST(root='./data', train=True, download=True, transform=transforms.Compose([transforms.ToTensor()]))

X_Train
#X_train.data
#X_train.targets

X_Train.data

"""datasets number 600000"""

!pip install qiskit_machine_learning

from qiskit.utils import algorithm_globals
algorithm_globals.random_seed = 12345

from qiskit_machine_learning.datasets import ad_hoc_data
train_data, train_labels, test_data, test_labels, sample_total = (
    ad_hoc_data(training_size=20, test_size=5, n=2, gap=0.3,
                include_sample_total=True, one_hot=False))

ad_hoc_data
train_data
test_data
print(np.asmatrix(sample_total).T)
sample_total.shape



from pyparsing.helpers import trace_parse_action
n_samples = 200
# Leaving only labels 0 and 1 
#idx_train = np.append(np.where(X_Train.targets == 0)[0][:n_samples],np.where(X_Train.targets == 1)[0][:n_samples])
idx_train0 = np.where(X_Train.targets == 0)[0][:n_samples]
idx_train1 = np.where(X_Train.targets == 1)[0][:n_samples]
print(idx_train0) 
print(idx_train1) 
print(len(idx_train0))
print(X_Train.data[0].ravel())
temp = X_Train.data[0].ravel()
#print(temp.shape())
#np.shape(X_Train.data[0].ravel())
unit = int(list(np.shape(X_Train.data[0].ravel()))[0])
print(unit)
print(np.shape(X_Train.data[idx_train0].ravel()))
Temp00 = X_Train.data[idx_train0].ravel()
Temp11 = X_Train.data[idx_train1].ravel()
#train1 = np.reshape(np.array(Temp0), int(len(idx_train0)), unit)
train0 = Temp00.reshape(len(idx_train0), unit)
train1 = Temp11.reshape(len(idx_train1), unit)

idx_train = [idx_train0, idx_train1]    
pixel = np.shape(X_Train.data[0])

#print(X_Train.data[i for i in idx_train0]) 

print(X_Train.data[idx_train1])
print(sum(X_Train.data[idx_train0]))
print(sum(X_Train.data[idx_train1]))
print(pixel)
print(np.shape(sum(X_Train.data[idx_train1],0)))
print(np.shape(sum(X_Train.data[idx_train1],1)))
print(np.shape(sum(X_Train.data[idx_train1],2)))
print(np.shape(sum(X_Train.data[idx_train1],100)))
print(np.shape(sum(sum(X_Train.data[idx_train1]))))
print(np.shape(X_Train.data[0][:][:]))
print(sum(X_Train.data[idx_train1])/sum(sum(X_Train.data[idx_train1])))


#print()
#x_train()



#train
X_train = X_Train
#X_train.data = [X_Train.data[idx_train0], X_Train.data[idx_train1]] 
#X_train.targets = [X_Train.targets[idx_train0], X_Train.targets[idx_train1]]
#X_train.data = [X_Train.data[idx_train[0]], X_Train.data[idx_train[1]]] 
#X_train.targets = [X_Train.targets[idx_train0], X_Train.targets[idx_train1]]
print(X_Train.data)
print(X_train.data)

X_train.data = []
#for i in [idx_train0[:], idx_train1[:]]:
for i in idx_train0:
  print(i)
  print(X_train.data[i])
  X_train.data.append(X_Train.data[i].ravel())

#print(idx_train1) 
#print(X_Train.data[i for i in idx_train1]) 

#for i in idx_train1:
#  X_train.data.append(X_Train.data[i])

#train_loader = torch.utils.data.DataLoader(X_train, batch_size=1, shuffle=True)

#test 
nsamples = 200

X_Test = datasets.MNIST(root='./data', train=False, download=True, transform=transforms.Compose([transforms.ToTensor()]))

#idx_test = np.append(np.where(X_Test.targets == 0)[0][:nsamples],np.where(X_Test.targets == 1)[0][:nsamples])
idx_test0 = np.where(X_Test.targets == 0)[0][:nsamples]
idx_test1 = np.where(X_Test.targets == 1)[0][:nsamples]

X_test = X_Test
#X_test.data = X_Test.data[idx_test]
#X_test.targets = X_Test.targets[idx_test]

#test_loader = torch.utils.data.DataLoader(X_test, batch_size=1, shuffle=True)

Temp0 = X_Test.data[idx_test0].ravel()
Temp1 = X_Test.data[idx_test1].ravel()
#train1 = np.reshape(np.array(Temp0), int(len(idx_train0)), unit)
test0 = Temp0.reshape(len(idx_test0), unit)
test1 = Temp1.reshape(len(idx_test1), unit)



import matplotlib.pyplot as plt
import numpy as np
import pylab as pl

#plot data
fig = plt.figure(figsize=(15, 5))
axdata = fig.add_subplot(111)
axdata.set_title("Data")
#axdata.set_ylim(0, 2 * np.pi)
#axdata.set_xlim(0, 2 * np.pi)
plt.scatter(train0[0,:],np.zeros(unit),
            marker='s', facecolors='w', edgecolors='C0',
            label="0-labeled train")
plt.scatter(train1[0,:],np.ones(unit),
            marker='o', facecolors='w', edgecolors='C3',
            label="1-labeled train")
plt.scatter(test0[0,:],np.zeros(unit),
            marker='s', facecolors='C0', label="0-labeled test")
plt.scatter(test1[1,:],np.ones(unit),
            marker='o', facecolors='C3', label="1-labeled test")
plt.legend()



# Plot class boundaries
#A = zip(Temp0[:],np.zeros(unit*200))
#B = zip(Temp1[:],np.ones(unit*200))
from matplotlib.colors import ListedColormap
fig = plt.figure(figsize=(15, 5))
cmap = ListedColormap(["C3","w","C0"])
axmap = fig.add_subplot(211)
axmap.set_title("Class Boundaries")
#axmap.imshow(np.asmatrix(np.array([np.array(A),np.array(B)])).T,
#             interpolation='nearest',
#             origin='lower', cmap=cmap,
#             extent=[0, 256, 0, 2])
#XX, YY = np.meshgrid([Temp0[:],Temp1[:]],[np.zeros(unit*200),np.ones(unit*200)])
XX, YY = np.meshgrid([Temp0[:2*unit],Temp1[:2*unit]],[np.zeros(unit*2),np.ones(unit*2)])
print(XX, YY)
print(XX.shape)
print(YY.shape)
#C = np.random.rand(unit*200, unit*200)
#C = np.random.rand(np.array(XX.shape))
#axmap.imshow(plt.pcolor(XX,YY,C))
axmap.imshow(np.asmatrix(YY), interpolation='nearest',
             origin='lower', cmap=cmap,
             extent=[0, 256, -10, 11])
#XX, YY = np.meshgrid([Temp0[:],Temp1[:]],[np.zeros(unit*200),np.ones(unit*200)])

axboth = fig.add_subplot(212)
axboth.set_title("Data overlaid on Class Boundaries")
axboth.imshow(np.asmatrix(YY), interpolation='nearest',
              origin='lower', cmap=cmap,
              extent=[0, 256, -10, 11])
axboth.scatter(train0[0,:],np.zeros(unit),
            marker='s', facecolors='w', edgecolors='C0',
            label="0-labeled train")
axboth.scatter(train1[0,:],np.ones(unit),
            marker='o', facecolors='w', edgecolors='C3',
            label="1-labeled train")
axboth.scatter(test0[0,:],np.zeros(unit),
            marker='s', facecolors='C0', label="0-labeled test")
axboth.scatter(test1[1,:],np.ones(unit),
            marker='o', facecolors='C3', label="1-labeled test")
plt.show()

from qiskit.circuit.library import ZZFeatureMap
# 2 features, depth 1
map_zz = ZZFeatureMap(feature_dimension=2, reps=1)
map_zz.decompose().draw()

from qiskit import opflow
def calculate_kernel(feature_map, x_data, y_data=None):
    """
        Calculates  kernel matrix from provided feature map and
        dataset(s), x & (y). If y isn't given, self inner product
        of x is calculated.
        No error checking is performed, feature map and datasets
        assumed to have the same dimension
    """
    if y_data is None:
        y_data = x_data
    # Use Operator Flow to create a list of feature map circuits,
    # parameterized by each data point
    x_circuits = opflow.CircuitStateFn(feature_map).bind_parameters(
        dict(zip(feature_map.parameters, np.transpose(x_data).tolist()))
        )
    y_circuits = opflow.CircuitStateFn(feature_map).bind_parameters(
        dict(zip(feature_map.parameters, np.transpose(y_data).tolist()))
        )
    # Compute the square of the conjugate inner product of the feature
    # map circuits: the kernel matrix
    kernel = np.abs(
        (~y_circuits.to_matrix_op() @ x_circuits.to_matrix_op()).eval()
    )**2
    return kernel

XX0, YY0 = np.meshgrid([Temp00[:unit],Temp11[:unit]],[np.zeros(unit),np.ones(unit)])
#adhoc_feature_map = ZZFeatureMap(feature_dimension=2, reps=1)
kernel = calculate_kernel(map_zz, YY0)
plt.figure(figsize=(5, 5))
plt.imshow(np.asmatrix(kernel),interpolation='nearest', origin='upper')
plt.title("Analytical Kernel Matrix")
plt.show()

XX1, YY1 = np.meshgrid([Temp0[:unit],Temp0[:unit]],[np.zeros(unit),np.ones(unit)])
#adhoc_feature_map = ZZFeatureMap(feature_dimension=2, reps=1)
kernel = calculate_kernel(map_zz, YY1)

#train_kernel = calculate_kernel(adhoc_feature_map, train_data)
test_kernel = calculate_kernel(map_zz, YY0, YY1)
# plot analytical matrices
fig, axs = plt.subplots(1, 2, figsize=(10,5))
axs[0].imshow(np.asmatrix(kernel), interpolation='nearest',
              origin='upper')
axs[0].set_title("Analytical Train Matrix")
axs[1].imshow(np.asmatrix(test_kernel), interpolation='nearest',
              origin='upper', cmap='Blues')
axs[1].set_title("Analytical Test Matrix")
plt.show()

# 4 features, depth 1
map_zz2 = ZZFeatureMap(feature_dimension=2, reps=2)
map_zz2.decompose().draw()
#from qiskit.utils import algorithm_globals
#algorithm_globals.random_seed = 12345

#train_data0, train_labels0, test_data0, test_labels0, sample_total0 = (
#    X_Train(training_size=25, test_size=25, n=2, gap=0.3,
#                include_sample_total=True, one_hot=False))

XX0, YY0 = np.meshgrid([Temp00[:unit],Temp11[:unit]],[np.zeros(unit),np.ones(unit)])
#adhoc_feature_map = ZZFeatureMap(feature_dimension=2, reps=1)
kernel2 = calculate_kernel(map_zz2, YY0)
plt.figure(figsize=(5, 5))
plt.imshow(np.asmatrix(kernel2),interpolation='nearest', origin='upper')
plt.title("Analytical Kernel Matrix")
plt.show()



XX1, YY1 = np.meshgrid([Temp0[:unit],Temp0[:unit]],[np.zeros(unit),np.ones(unit)])
#adhoc_feature_map = ZZFeatureMap(feature_dimension=2, reps=1)
kernel2 = calculate_kernel(map_zz2, YY1)

#train_kernel = calculate_kernel(adhoc_feature_map, train_data)
test_kernel2 = calculate_kernel(map_zz2, YY0, YY1)
# plot analytical matrices
fig, axs = plt.subplots(1, 2, figsize=(10,5))
axs[0].imshow(np.asmatrix(kernel2), interpolation='nearest',
              origin='upper')
axs[0].set_title("Analytical Train Matrix")
axs[1].imshow(np.asmatrix(test_kernel2), interpolation='nearest',
              origin='upper', cmap='Blues')
axs[1].set_title("Analytical Test Matrix")
plt.show()

!pip install sklearn

from qiskit.providers.basicaer import unitary_simulator
from sklearn.svm import SVC
# train scikit-learn svm model
model = SVC(kernel='precomputed')
model.fit(kernel, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))
print("Number of support vectors for each class:",model.n_support_)
print("Indices of support vectors:", model.support_)

# Plot support vectors
#plt.figure(figsize=(5, 5))
#plt.ylim(0, 2 * np.pi)
#plt.xlim(0, 2 * np.pi)
#plt.scatter(train_data[model.support_[0:model.n_support_[0] ], 0],
#            train_data[model.support_[0:model.n_support_[0] ], 1],
#            marker='s', label="A support")
#plt.scatter(train_data[model.support_[model.n_support_[0]:], 0],
#            train_data[model.support_[model.n_support_[0]:], 1],
#            marker='o', c='C3', label="B support")
#plt.legend(loc='upper left', frameon=False)
#plt.show()
#plot data
fig = plt.figure(figsize=(15, 5))
axdata = fig.add_subplot(111)
axdata.set_title("Data")
#axdata.set_ylim(0, 2 * np.pi)
#axdata.set_xlim(0, 2 * np.pi)
plt.scatter(train0[0,:],np.zeros(unit),
            marker='s', facecolors='w', edgecolors='C0',
            label="0-labeled train support")
plt.scatter(train1[0,:],np.ones(unit),
            marker='o', facecolors='w', edgecolors='C3',
            label="1-labeled train")
plt.scatter(test0[0,:],np.zeros(unit),
            marker='s', facecolors='C0', label="0-labeled test")
plt.scatter(test1[1,:],np.ones(unit),
            marker='o', facecolors='C3', label="1-labeled test")
plt.legend()

# test svm model
model.score(test_kernel, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))

from qiskit.providers.basicaer import unitary_simulator
from sklearn.svm import SVC
# train scikit-learn svm model
model2 = SVC(kernel='precomputed')
model2.fit(kernel2, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))
print("Number of support vectors for each class:",model2.n_support_)
print("Indices of support vectors:", model2.support_)

# test svm model
model2.score(test_kernel2, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))



from qiskit import BasicAer
from qiskit_machine_learning.kernels import QuantumKernel
# Create the quantum feature map
adhoc_feature_map = ZZFeatureMap(feature_dimension=2,reps=1,entanglement='linear')
# Create the quantum kernel
adhoc_kernel = QuantumKernel(feature_map=adhoc_feature_map,quantum_instance=BasicAer.get_backend(
                                             'statevector_simulator'))

# Set the SVC algorithm to use our custom kernel
adhoc_svc = SVC(kernel=adhoc_kernel.evaluate)
adhoc_svc.fit(YY0, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))
adhoc_svc.score(YY1, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))

from qiskit import BasicAer
from qiskit_machine_learning.kernels import QuantumKernel
# Create the quantum feature map
adhoc_feature_map2 = ZZFeatureMap(feature_dimension=2,reps=2,entanglement='linear')
# Create the quantum kernel
adhoc_kernel2 = QuantumKernel(feature_map=adhoc_feature_map2,quantum_instance=BasicAer.get_backend(
                                             'statevector_simulator'))

# Set the SVC algorithm to use our custom kernel
adhoc_svc2 = SVC(kernel=adhoc_kernel2.evaluate)
adhoc_svc2.fit(YY0, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))
adhoc_svc2.score(YY1, np.array(([np.zeros(unit),np.ones(unit)])).reshape(2*unit))

idx_train





"""X_train = datasets.MNIST(root='./data', train=True, download=True, transform=transforms.Compose([transforms.ToTensor()]))

"""